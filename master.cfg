# -*- python -*-
# ex: set filetype=python:

from buildbot.plugins import *
from twisted.python import log
import bbconf
import ldapauth
import os.path
import importlib
from datetime import timedelta

scenarios_and_dependences = []
selfupdate_repourl = 'git://github.com/nextgis/buildbot.git'
buildbot_path = '/opt/buildbot'

def addScenario(c, name):
    scenario = importlib.import_module(name)
    reload(scenario)

    for key, value in scenario.c.items():
        log.msg("Add scenario. Append '{}':{}".format(
            key,
            [item.name for item in value])
        )

        c[key].extend(value)

    #scenarios_and_dependences.append(name + ".py")
    if hasattr(scenario, 'dependent_local_modules'):
        scenarios_and_dependences.extend(scenario.dependent_local_modules)

# This is a sample buildmaster config file. It must be installed as
# 'master.cfg' in your buildmaster's base directory.

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}
c['status'] = []
c['change_source'] = []
c['schedulers'] = []
c['builders'] = []
c['services'] = []

####### Clean logs
c['configurators'] = [util.JanitorConfigurator(
    logHorizon=timedelta(weeks=4),
    hour=12,
    dayOfWeek=6)]

####### WORKERS

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password.  The same
# worker name and password must be configured on the worker.
c['workers'] = [
    worker.Worker("build-nix", bbconf.slave_passwd, max_builds=3),
    worker.Worker("build-win", bbconf.slave_passwd, max_builds=1),
    worker.Worker("build-mac", bbconf.slave_passwd, max_builds=1)
]

scenarios = ['updatedocs', 'makedocs', 'makegeos', 'makecgal', 'makeopencad',
             'makengm3', 'makengidtests', 'makegdal', 'makeformbuilder',
            ]
for scenario in scenarios:
    scenarios_and_dependences.append(scenario + ".py")

# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that workers
# could connect to your master with this protocol.
# 'port' must match the value configured into the workers (with their
# --master option)
c['protocols'] = {'pb': {'port': 9989}}

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.  Here we point to the buildbot clone of pyflakes.

c['change_source'].append(changes.GitPoller(
	project = 'nextgis/buildbot',
    repourl = selfupdate_repourl,
	workdir = 'selfupdate-workdir',
    branch = 'master',
    pollinterval = 600))

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.  In this
# case, just kick off a 'runtests' build

c['schedulers'].append(schedulers.SingleBranchScheduler(
                            name="selfupdate",
                            change_filter=util.ChangeFilter(project='nextgis/buildbot'),
                            treeStableTimer=2*60,
                            builderNames=["selfupdate"]))
c['schedulers'].append(schedulers.ForceScheduler(
                            name="force",
                            builderNames=["selfupdate"]))

### Add scenarios
for scenario in scenarios:
    if os.path.isfile(scenario + ".py"):
        addScenario(c, scenario)

####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which workers can execute them.  Note that any particular build will
# only take place on one worker.

factory = util.BuildFactory()
# check out the source
factory.addStep(steps.Git(repourl=selfupdate_repourl, mode='incremental'))
# run the tests (note that this will require that 'trial' is installed)
factory.addStep(steps.FileUpload(
    workersrc="master.cfg",
    masterdest=buildbot_path + "/master/master.cfg",
    mode=0644)
)

for filename in scenarios_and_dependences:
    factory.addStep(
        steps.FileUpload(
            workersrc=filename,
            masterdest=buildbot_path + "/master/" + filename,
            mode=0644
        )
    )

factory.addStep(steps.MasterShellCommand(
    name="reconfig",
    description=["reconfigure", "buildbot"],
    descriptionDone=["reconfigured", "buildbot"],
    haltOnFailure=True,
    command=[buildbot_path + "/sandbox/bin/buildbot", "reconfig", buildbot_path + "/master"])
)

c['builders'].append(
    util.BuilderConfig(
        name="selfupdate",
        workernames=["build-nix"],
        factory=factory)
    )

####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.

template=u'''\
<h4>Build status: {{ summary }}</h4>
<p> Worker used: {{ workername }}</p>
<p> Steps:<br>
{% for step in build['steps'] %}
{{ step['name'] }}: {{ step['result'] }}<br>
{% endfor %}
</p>
<p><b>--<br>
Your NextGIS BuildBot</b></p>
mailto:buildbot@nextgis.com<br>
web:https://buildbot.nextgis.com<br>
'''

m = reporters.MailNotifier(
    fromaddr="buildbot@nextgis.com",
    mode=('change', 'failing', 'passing', 'problem', 'warnings', 'exception'),
    extraRecipients=bbconf.email_recipients,
    relayhost="192.168.255.1",
    useTls=True,
    sendToInterestedUsers=False,
#    messageFormatter=reporters.MessageFormatter(
#        template=template, template_type='html',
#        wantProperties=True, wantSteps=True)
)
c['services'].append(m)

# context = util.Interpolate("buildbot/%(prop:buildername)s")
gs = reporters.GitHubStatusPush(
    token=bbconf.githubAPIToken,
#    context=context,
    startDescription='Build started.',
    endDescription='Build done.'
)
c['services'].append(gs)

# TODO:
# gc = status.GitHubCommentPush(token=bbconf.githubAPIToken,
#                               startDescription='Build started.',
#                               endDescription='Build done.')
# c['services'].append(gc)

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot installation's
# home pages (linked to the 'titleURL').

c['title'] = "NextGIS"
c['titleURL'] = "http://nextgis.ru"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server is visible. This typically uses the port number set in
# the 'www' entry below, but with an externally-visible host name which the
# buildbot cannot figure out without some help.

c['buildbotURL'] = "https://buildbot.nextgis.com/"

# minimalistic config to activate new web UI
c['www'] = {
    'port': 8010,
    'plugins': {
	'waterfall_view': {},
	'console_view': {}
    },
    'versions':[
        ('master.cfg', '2.1.1'),
    ],
    'auth': ldapauth.LDAPAuth('ldap://192.168.250.1', 'dc=nextgis,dc=com', 'buildbot'),
    'authz': util.Authz(
        allowRules=[
	    util.AnyEndpointMatcher(role="buildbot", defaultDeny=True),
	],
        roleMatchers=[
	    util.RolesFromGroups()
	]
    )
}


####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : "sqlite:///state.sqlite",
}

####### Sentry

from raven import Client
from raven.transport.twisted import TwistedHTTPTransport

client = Client(bbconf.sentry_dsn, transport=TwistedHTTPTransport)

def logToSentry(event):

    if not event.get('isError') or 'failure' not in event:
        return
    client.captureException()

log.addObserver(logToSentry)

import logging
logger = logging.getLogger('sentry.errors')
logger.setLevel(logging.INFO)
logger.addHandler(logging.StreamHandler())
